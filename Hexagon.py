from manim import *
from numpy import right_shift

class HexagonStuff(Scene):
    def construct(self):
        bee_hex = ImageMobject("Assets/Images/honey comb cells.jpg")
        eye_hex = ImageMobject("Assets/Images/cross section.png")
        cb = ImageMobject("Assets/Images/carbon bond.jpeg")
        saturn = ImageMobject("Assets/Images/saturn hexagon.jpeg")
        bee_eye = ImageMobject("Assets/Images/bee_eye.jpg")
        bee_eye.generate_target()
        self.add_sound("Assets/Music/Resonance.mp3")
        s = Square()
        s.scale(0.5).to_edge(LEFT)
        c = Circle(color=WHITE)
        c.scale(0.5).to_edge(RIGHT)
        sc_gr = VGroup(s,c)
        bee_hex.scale(0.8)
        self.add(bee_hex)
        self.wait(2)
        q1 = Text("Why are Honeycomb cells hexagonal?") # Phrase this exact question during the live presentation
        q1.to_edge(DOWN)
        self.play(Write(q1))
        self.wait(4)
        self.play(Create(sc_gr)) # It's not like that we have run out of polygons to use
        self.wait(5)
        self.play(FadeOut(bee_hex, q1, sc_gr))
        # There's actually a very important reason why hexagons show up everywhere in nature
        honey = ImageMobject("Assets/Images/honey drop.png") # picture of honey
        wax = ImageMobject("Assets/Images/beehive.jpeg") # picture of wax
        honey.shift(5*LEFT)
        wax.shift(2*RIGHT)
        self.play(FadeIn(honey, wax))
        self.wait(2)
        self.play(FadeOut(honey, wax))
        # Bees make wax to contain the honey
        hc_cell = ImageMobject("Assets/Images/cells filled with honey.jpeg") # honey comb cell
        self.play(FadeIn(hc_cell))
        self.wait(8)
        self.play(FadeOut(hc_cell))
        # It's really important to make sure the hexagonal cells contain the maximum honey while using the minimum wax
        # Here an interesting problem arisises
        # What's the shape that take the least perimeter and manages to cover the most area at the same time
        t = Triangle(color = WHITE)
        t.scale(3)
        s2 = Square(color = WHITE)
        s2.scale(2.8)
        t.shift(3*LEFT)
        s2.shift(3*RIGHT)
        P1 = Text("Perimeter of the triangle = 3")
        P1.next_to(t, DOWN).scale(.5)
        P2 = Text("Perimeter of the square = 2.6321")
        P2.next_to(s2, DOWN).scale(.5)
        self.play(Create(t))
        self.play(Create(s2))
        self.play(Create(P1))
        self.play(Create(P2))
        self.wait(7)
        # It'd be illogical to have polygons with too many edges since that'd add considerably to the area of the shape
        # One another reason to not do that would be because that'd make our polygons leave space in between
        # To make sure that the polygons don't leave any space in between we'll have to make sure that their angles add upto 360 degrees
        # and that's only going to happen if the angle is a factor of 360
        # so let's look at the factors of a 360 degree angle
        self.play(FadeOut(t, s2, P1, P2))
        self.wait(2)
        factors = Tex(r"The factors of $360^{\circ}$ that we care about are $120^{\circ}, 90^{\circ}$ and $60^{\circ}$ because $60^{\circ}$ is the smallest possible angle a polygon can have")
        factors.scale(.7)
        self.play(Write(factors))
        self.wait(2)
        self.play(FadeOut(factors))
        hexagon = RegularPolygon(n = 6, color = WHITE)
        hexagon.shift(3*RIGHT)
        t_smol = Triangle(color = WHITE)
        s_smol = Square(color = WHITE)
        s_smol.shift(3*LEFT)
        sgrp = VGroup(t_smol, s_smol, hexagon)
        self.play(Create(sgrp))
        self.wait(3)
        self.play(FadeOut(t_smol))
        hexagon.generate_target()
        s_smol.generate_target()
        hexagon.target.scale(3)
        s_smol.target.scale(3)
        hexagon.target.to_edge(RIGHT).shift(UP)
        s_smol.target.to_edge(LEFT).shift(UP)
        
        self.play(
            MoveToTarget(hexagon),
            MoveToTarget(s_smol)
        )
        self.wait(1)
        try1 = Text("Let's try to find the perimeters of both these shapes!")
        try1.to_edge(DOWN).scale(.8)
        self.play(Write(try1))
        self.wait(2)
        self.play(FadeOut(s_smol, try1))
        self.wait(1)
        self.play(ApplyMethod(hexagon.shift, 4*LEFT + DOWN))
        self.wait(2)        
        # why the hexagon works >>> than a square or a triangle
        line1  = Line(hexagon.get_vertices()[0], hexagon.get_vertices()[3])
        line2  = Line(hexagon.get_vertices()[1], hexagon.get_vertices()[4])
        line3  = Line(hexagon.get_vertices()[2], hexagon.get_vertices()[5])
        line_party = VGroup(line1, line2, line3)
        self.play(Create(line_party))
        self.wait(3)

        area1 = Tex(r"Area = $6\left(\frac{\sqrt{3}b^2}{4} \right)$")
        area1.shift(3*UP + 5*RIGHT)
        area2 = Tex(r"        = $\frac{3\sqrt{3}b^2}{2}$")
        area2.shift(2*UP + 5*RIGHT)
        perimeter = Tex(r"Perimeter = $6b$")
        perimeter.shift(UP + 5*RIGHT)
        s = Square()
        s.scale(2)
        a_area = Tex(r"Area = $a^2$")
        a_area.shift(5*RIGHT)
        a_perimeter = Tex(r"Perimeter = $4a$")
        a_perimeter.shift(DOWN + 5*RIGHT)
        a1 = Tex(r"$a$")
        a1.next_to(s, DOWN)
        a2 = Tex(r"$a$")
        a2.next_to(s, LEFT)
        a3 = Tex(r"$a$")
        a3.next_to(s, UP)
        a4 = Tex(r"$a$")
        a4.next_to(s, RIGHT)
        edge_labels = VGroup(a1, a2, a3, a4)
        
        

        things = VGroup(
            area1,
            area2,
            perimeter,
            s,
            a_area,
            a_perimeter     

        )
        pt = {"run_time": 1}
        self.play(Write(things[0]))
        self.play(Write(things[1]))
        self.wait(1)
        self.play(Write(things[2]))
        self.wait(3)
        self.play(FadeOut(line_party, hexagon))
        self.wait(1)
        self.play(Create(things[3]))
        self.play(Write(edge_labels))
        self.play(Write(things[4]))
        self.wait(1)
        self.play(Write(things[5]))
        
        lines = VGroup(
            Tex(r"$a^2$", r"$ = $", r"$\frac{3\sqrt{3} b^2}{2}$"),
            Tex(r"$a$", r"$ = $", r"$\sqrt{\frac{3\sqrt{3} b^2}{2}}$")
        )
        pt = {"run_time": 1}
        lines[0].to_edge(LEFT).shift(UP)
        lines[1].shift(3*LEFT)
        self.play(Write(lines[0]))
        self.play(
            TransformMatchingTex(
                lines[0].copy(), lines[1].to_edge(LEFT),
                path_arc=90 * DEGREES,
            ),
            **pt
        ) 
        self.wait(3)
        p_square = Tex(r"$\text{Perimeter}_\text{square} = 4a$")
        p_square.to_edge(LEFT).shift(DOWN)
        P_square = Tex(r"         = $4\sqrt{\frac{3\sqrt{3}b^2}{2}}$")
        P_square.to_edge(LEFT).shift(2*DOWN)
        self.play(Write(p_square))
        self.play(Write(P_square))
        self.wait(3)
        self.play(FadeOut(things, lines, p_square, P_square, edge_labels))
        self.wait(2)
        ratio1 = Tex(r"$\text{P}_\text{Square} : \text{P}_\text{Hexagon}$")
        ratio1.to_edge(UP)
        ratio2 = Tex(r"$4\sqrt{\frac{3\sqrt{3} b^2}{2}} : 6b$")
        ratio2.to_edge(UP).shift(DOWN)
        rearrange = Text("We can rearrange this ratio to get ")
        rearrange.to_edge(UP).shift(2*DOWN)        
        final_ratio = Tex(r"$\frac{2\sqrt{3}}{3} : 1$")
        final_ratio.to_edge(UP).shift(3*DOWN)
        approx = Tex(r"$\text{P}_\text{Square} : \text{P}_\text{Hexagon} \approx 1.155 : 1$")
        approx.to_edge(UP).shift(4*DOWN)
        self.play(Write(ratio1))
        self.play(Write(ratio2))
        self.play(Write(rearrange))
        self.play(Write(final_ratio))
        self.play(Write(approx))
        self.wait(3)
        triangle_try = Text("Now let's try to figure out if this is the same case with a triangle as well")
        triangle_try.to_edge(DOWN).scale(.7)
        self.play(Write(triangle_try))
        self.wait(2)
        self.play(FadeOut(ratio1, ratio2, rearrange, final_ratio, approx, triangle_try))
        tri = Triangle()
        tri.scale(2)
        self.play(Create(tri))
        c1 = Text("a").next_to(tri, LEFT).shift(.7*RIGHT + .3*UP)
        c2 = Text("a").next_to(tri, LEFT).shift(3.7*RIGHT + .3*UP)
        c3 = Text("a").next_to(tri, DOWN)
        cgrp = VGroup(c1, c2, c3)
        self.play(Write(cgrp))
        tri_area = Tex(r"Area = $\frac{\sqrt{3}a^2}{4}$")
        tri_area.to_edge(RIGHT).shift(2*UP)
        tri_perimeter = Tex(r"Perimeter = 3a")
        tri_perimeter.to_edge(RIGHT).shift(UP)
        self.wait(3)
        self.play(Write(tri_area))
        self.play(Write(tri_perimeter))
        self.wait(2)
        a_as_b = Tex(r"$\frac{\sqrt{3}a^2}{4} = \frac{3\sqrt{3}b^2}{2}$")
        a_as_b.to_edge(LEFT).shift(2*UP)
        a_as_b2 = Tex(r"$a = \sqrt{6}b$")
        a_as_b2.to_edge(LEFT).shift(UP)
        self.play(Write(a_as_b))
        self.play(Write(a_as_b2))
        self.wait(2) 
        self.play(FadeOut(tri_area, tri_perimeter, tri, a_as_b, a_as_b2, cgrp))
        tratio1 = Tex(r"$\text{P}_\text{Triangle} : \text{P}_\text{Hexagon}$")
        tratio1.to_edge(UP)
        tratio2 = Tex(r"$3\sqrt{6}b : 6b$")
        tratio2.to_edge(UP).shift(DOWN)
        trearrange = Text("We'll get this on further simplification")
        trearrange.to_edge(UP).shift(2*DOWN)        
        tfinal_ratio = Tex(r"$\sqrt{\frac{3}{2}} : 1$")
        tfinal_ratio.to_edge(UP).shift(3*DOWN)
        tapprox = Tex(r"$\text{P}_\text{Triangle} : \text{P}_\text{Hexagon} \approx 1.225 : 1$")
        tapprox.to_edge(UP).shift(4*DOWN)
        k = Text("We can confirm from this too that the hexagon occupies the same area as a triangle with lesser perimeter to speak of!")
        k.scale(0.4).to_edge(UP).shift(5*DOWN)
        self.play(Write(tratio1))
        self.play(Write(tratio2))
        self.wait(1)
        self.play(Write(trearrange))
        self.wait(1)
        self.play(Write(tfinal_ratio))
        self.wait(2)
        self.play(Write(tapprox))
        self.wait(2)
        self.play(Write(k))
        self.wait(5)
        
        # Wrapping up
        wrappinguptext = Text("The property of hexagon that it occupies the most area with the least perimeter" +  "when tiled is a property that makes it appear all over the universe")
        wrappinguptext.scale(.45).to_edge(DOWN)
        self.play(Write(wrappinguptext))
        self.wait(2)
        self.play(FadeOut(tratio1, tratio2, trearrange, tfinal_ratio, tapprox, k, wrappinguptext))
        self.add(bee_eye)
        bee_eye.target.scale(.25)
        bee_eye.target.to_corner(UP + LEFT)
        self.wait(3)
        self.play(MoveToTarget(bee_eye))
        saturn.scale(.5).to_corner(UP + RIGHT)
        self.add(saturn)
        self.wait(2)
        cb.scale(2).to_corner(DOWN + LEFT)
        self.add(cb)
        self.wait(2)
        eye_hex.scale(2).to_corner(DOWN + RIGHT)
        self.add(eye_hex)
        self.wait(5)

        

